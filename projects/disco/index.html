<!--
  layout: default
  title: "DIS-CO: Discovering Copyrighted Content in VLMs Training Data"
  navbar_title: "DIS-CO"
-->

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="Deformable Neural Radiance Fields creates free-viewpoint portraits (nerfies) from casually captured videos.">
  <meta name="keywords" content="Nerfies, D-NeRF, NeRF">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Tom Select CSS and JS -->
  <link href="https://cdn.jsdelivr.net/npm/tom-select@2.2.2/dist/css/tom-select.css" rel="stylesheet"/>
  <script src="https://cdn.jsdelivr.net/npm/tom-select@2.2.2/dist/js/tom-select.complete.min.js"></script>

  <title>DIS-CO: Discovering Copyrighted Content in VLMs Training Data</title>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-PYVRSFMDRL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-PYVRSFMDRL');
  </script>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,500,700">

  <!-- Bulma CSS -->
  <link rel="stylesheet" href="./static/css/bulma.min.css">
  <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
  
  <!-- FontAwesome & Academicons -->
  <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  
  <!-- Your Custom CSS -->
  <link rel="stylesheet" href="./static/css/index.css">
  
  <!-- Favicon -->
  <link rel="icon" href="./static/images/disco_ball_icon.png">

  <!-- jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  
  <!-- Bootstrap CSS AFTER Bulma so that the navbar styles take precedence -->
  <link rel="stylesheet" 
        href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/css/bootstrap.min.css"
        integrity="sha512-P5MgMn1jBN01asBgU0z60Qk4QxiXo86+wlFahKrsQf37c9cro517WzVSPPV1tDKzhku2iJ2FVgL67wG03SGnNA=="
        crossorigin="anonymous" />

  <!-- Bootstrap JS (with Popper.js) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
          integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
          crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.min.js"
          integrity="sha512-XKa9Hemdy1Ui3KSGJdgMyYlUg1gM+QhL6cnlyTe2qzMCYm4nAZ1PsVerQzTTXzonUR+dmswHqgJPuwCq1MaAg=="
          crossorigin="anonymous"></script>
  
  <!-- FontAwesome, Bulma Carousel, etc. -->
  <script defer src="./static/js/fontawesome.all.min.js"></script>
  <script src="./static/js/bulma-carousel.min.js"></script>
  <script src="./static/js/bulma-slider.min.js"></script>
  <script src="./static/js/index.js"></script>

  <!-- d3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>

    /* Slightly increase the base font size */
    body {
        font-size: 20px; /* Default is 16px, increase it slightly */
        color: #424242 !important; /* Change default text color */
    }

    p {
    margin-bottom: 12px !important; /* Slightly increase spacing between paragraphs */
    }


    .title.is-3{
      color: #3e3e3e !important;
      font-weight: bold;
      margin-top: -2rem;
    }

    .title.is-4 {
      color: #686868 !important;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .navigation-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;      
      width: fit-content;
      margin: 1rem auto;
    }
    .navigation-controls button {
      width: 5%;
      margin: 0;
    }
    .round-button {
      width: 3rem !important;
      height: 3rem !important;
      min-width: 3rem !important; 
      padding: 0 !important;
      border-radius: 50% !important;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem !important;
      box-sizing: border-box;
      background-color: #626161 !important;
      color: #ffffff !important;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }
    .round-button::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 10px;
      height: 10px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      pointer-events: none;
    }
    .round-button:active::after {
      animation: ripple 0.6s ease-out;
    }
    .round-button:hover {
      transform: scale(0.95);
    }
    @keyframes ripple {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0.5; }
      100% { transform: translate(-50%, -50%) scale(4); opacity: 0; }
    }
    .round-button:active {
      transform: scale(0.9);
    }
    #dot-indicators {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      justify-content: center;
    }
    #dot-indicators .dot {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin: 0 4px;
      background-color: #ddd;
      border-radius: 50%;
      transition: transform 0.3s, background-color 0.3s;
    }
    #dot-indicators .dot.active {
      background-color: #626161;
      transform: scale(1.2);
    }
    .answer-container {
      background-color: #fff;
      border: 1px solid #ccc;
      padding: 1.5rem;
      border-radius: 10px;
      width: 100%;
    }
    /* New wrapper for TomSelect and submit button */
    #quiz-answer-wrapper {
      position: relative;
      width: 60%;
      margin: 1rem auto 0;
      /* Height is set dynamically by JS based on the TomSelect container */
    }
    /* Both inner containers are absolutely positioned to overlap */
    #quiz-container,
    #submit-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
    }
    /* Initially show the TomSelect container, hide submit button */
    #submit-container { display: none; }
    /* When the wrapper has the .show-submit class, toggle displays */
    #quiz-answer-wrapper.show-submit #quiz-container {
      display: none;
    }
    #quiz-answer-wrapper.show-submit #submit-container {
      display: block;
    }
    .ts-wrapper .ts-control {
      background: #F0F3F7;
      border: 1px solid #ccc;
      border-radius: 8px;
      position: relative;
      padding: 0.375rem 1.75rem 0.375rem 0.75rem;
    }
    .ts-wrapper .ts-control:hover,
    .ts-wrapper .ts-control:focus-within {
      box-shadow: none;
    }
    .ts-wrapper .ts-control::after {
      content: "";
      background-image: url('./static/images/arrow_down_sign.png'); 
      background-size: contain;
      background-repeat: no-repeat;
      position: absolute;
      right: 0.75rem;
      top: 50%;  
      width: 1.0rem;  
      height: 1.0rem;
      transform: translateY(-50%);
      pointer-events: none;
    }
    .ts-wrapper .ts-control input {
      background: transparent;
      border: none;
      outline: none;
    }
    .ts-wrapper .ts-dropdown {
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    select#quiz-answer { display: none !important; }
    #submit-all {
      border-radius: 10px;
      background-color: #F0F3F7;
      border: none;
      color: #515151;
      text-transform: uppercase;
      font-weight: bold;
      font-size: 1rem;
      padding: 0.75rem 1.5rem;
      box-shadow: 0 4px 0 #cccccc;
      cursor: pointer;
      transition: all 0.1s ease-in-out;
    }
    #submit-all:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 0 #cccccc;
    }
    .text-label {
      font-size: 16px;
      font-weight: 600;
      fill: #333;
    }
    .axis text {
      font-size: 15px;
      fill: #464646;
      font-weight: 500;
    }
    .bar-text {
      font-size: 18px;
      font-weight: bold;
      fill: #333;
    }
    .text-label, .axis text, .bar-text { font-family: 'Roboto', sans-serif; }
    .legend-text {
      font-family: 'Roboto', sans-serif;
      font-size: 16px;
      font-weight: 600;
      fill: #464646;
    }
    .legend-square { vector-effect: non-scaling-stroke; }
    @media screen and (max-width: 1000px) {
      .legend-text { font-size: 12px !important; }
      .legend-square { width: 8px !important; height: 8px !important; }
    }
    @media screen and (max-width: 1000px) {
      figure.chart-or-image, #quiz-answer-wrapper { width: 90% !important; }
    }

    @media screen and (max-width: 1000px) {
    .image-wrapper {
      width: 100% !important;
    }
    .image-wrapper img {
      width: 90% !important; /* Makes the image fill the div */
    }
  }
    .image-wrapper{
      justify-content: center;
      align-items: center;
      margin-bottom: 20px; /* Adjust margin-bottom as needed */
    }



/* --- Modern Tab Styling --- */
.custom-tabs {
  margin-bottom: 1.5rem !important;
  border-bottom: 1px solid #e0e0e0 !important;
  font-family: 'Roboto', sans-serif !important;
}

.custom-tabs ul {
  display: flex !important;
  justify-content: center !important;
  list-style: none !important;
  padding: 0 !important;
  margin: 0 !important;
}

.custom-tabs ul li {
  padding: 0.75rem 1.5rem !important;
  margin: 0 0.5rem !important;
  cursor: pointer !important;
  position: relative !important;
  font-size: 1.1rem !important;
  color: #9e9e9e !important;
  transition: color 0.25s ease !important;
}

.custom-tabs ul li:not(.is-active):hover {
  color: rgb(47, 47, 47) !important;
}

.custom-tabs ul li.is-active {
  color: #464646 !important;
  font-weight: 600 !important;
}

.custom-tabs ul li.is-active::after {
  content: '' !important;
  position: absolute !important;
  left: 0 !important;
  right: 0 !important;
  bottom: -1px !important;
  height: 3px !important;
  background-color: #464646 !important;
  border-radius: 2px !important;
}

/* --- Card-like Table Container --- */
.table-card {
  margin: 0 auto !important;
  max-width: 100% !important;
}

/* Responsive table styling using Bulma */
table.table {
  width: 100% !important;
  font-family: 'Roboto', sans-serif !important;
  border-collapse: collapse !important;

}

/* Make Colums take always the same width */
table.table th:nth-child(n+2),
table.table td:nth-child(n+2) {
  width: 20% !important;
}

/* Centered, refined caption styling */
table.table caption {
  caption-side: top !important;
  text-align: center !important;
  font-weight: 600 !important;
  margin-bottom: 0.75rem !important;
  font-size: 1.15rem !important;
  color: #464646 !important;
}

/* Optional: subtle table cell styling */
table.table th,
table.table td {
  padding: 0.75rem !important;
  border: 1px solid #f0f0f0 !important;
  text-align: center !important;
  font-size: clamp(0.65rem, 2vw, 1rem) !important;
  color: #464646 !important;
}

table.table th {
  background: #fafafa !important;
  vertical-align: middle !important;
}

.table-card table.table th:first-child,
.table-card table.table td:first-child {
  white-space: nowrap !important;
  text-align: left !important;
}

.table-card table.table thead th:nth-child(2) {
  white-space: nowrap !important;
}

.table-card table.table thead th:first-child {
  background: transparent !important;
  border-top: none !important;
  border-left: none !important;
}




  </style>
</head>
<body>

  <!-- Begin Bulma-Based Page Content -->

  <section class="hero">
    <div class="hero-body">
      <div class="container is-max-desktop">
        <div class="columns is-centered">
          <div class="column has-text-centered">
            <h1 class="title is-1 publication-title">
              DIS-CO: Discovering Copyrighted Content in VLMs Training Data
            </h1>
            <div class="is-size-5 publication-authors">
              <span class="author-block">
                <a href="/">André V. Duarte</a><sup>1,2</sup>,
              </span>
              <span class="author-block">
                <a href="https://xuandongzhao.github.io/">Xuandong Zhao</a><sup>3</sup>,
              </span>
              <span class="author-block">
                <a href="https://web.tecnico.ulisboa.pt/arlindo.oliveira/">Arlindo L. Oliveira</a><sup>2</sup>,
              </span>
              <span class="author-block">
                <a href="https://lileicc.github.io/">Lei Li</a><sup>1</sup>,
              </span>
            </div>
            <div class="is-size-5 publication-authors">
              <span class="author-block"><sup>1</sup>Carnegie Mellon University,</span>
              <span class="author-block"><sup>2</sup>Instituto Superior Técnico</span>
              <span class="author-block"><sup>3</sup>UC Berkeley</span>
            </div>
            <div class="column has-text-centered">
              <div class="publication-links">
                <!-- PDF Link -->
                <span class="link-block">
                  <a href="https://arxiv.org/pdf/2011.12948" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon"><i class="fas fa-file-pdf"></i></span>
                    <span>Paper</span>
                  </a>
                </span>
                <!-- Code Link -->
                <span class="link-block">
                  <a href="https://github.com/avduarte333/DIS-CO" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon"><i class="fab fa-github"></i></span>
                    <span>Code</span>
                  </a>
                </span>
                <!-- Dataset Link -->
                <span class="link-block">
                  <a href="https://huggingface.co/datasets/DIS-CO/MovieTection" class="external-link button is-normal is-rounded is-dark">
                    <span class="icon"><i class="far fa-images"></i></span>
                    <span>Data</span>
                  </a>
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>


  <!-- Teaser Section -->
  <section class="section">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column is-four-fifths has-text-centered">
          <p>
            Motivated by the hypothesis that a VLM is able to recognize images from its training data, we propose <b>DIS-CO</b>, a novel approach to infer the inclusion of copyrighted content during the model's development.
          </p>
          <div class="image-wrapper">
            <img src="./static/images/crown_figure.png" style="width: 70%; height: auto; display: block; margin: 0 auto;">
          </div>
        </div>
      </div>
    </div>
  </section>


  
  <!-- Abstract Section -->
  <section class="section">
    <div class="container is-max-desktop">
      <div class="columns is-centered has-text-left">
        <div class="column is-four-fifths">
          <h2 class="title is-3">Introduction</h2>
          <div class="content has-text-justified">
            <p>
              Large Vision-Language Models (VLMs) are trained on vast datasets scraped from the web, often with little transparency regarding data sources. This raises ethical and legal concerns, particularly when copyrighted content is suspected of having been used.
            </p>
            <p>
                <span style="font-weight: 600;">So how can we verify whether a VLM has seen a specific copyrighted work without access to its training data?</span>
            </p>
          
          <h2 class="title is-4">The Key Idea:</h2>
            <p>
              In a black-box setting — where model attributes like token probabilities are inaccessible — the most reliable way to determine whether a model has seen specific content is to make it reveal knowledge that goes beyond general understanding.<br>
              To achieve this, we need a task designed with two key properties:
              <ul>
                <li>
                  <span style="font-weight: 600;">The success rate is low if the target content was not in training.</span> This helps reduce false positives and ensures that models are not merely guessing correctly by chance.
                </li>
                <li>
                  <span style="font-weight: 600;">A high success rate indicates the target content was in training.</span> If a model consistently provides correct responses, it strongly suggests prior exposure to that content.
                </li>
              </ul>
              We propose a <em>Frame-to-Title Prediction</em> task. Simply put, if a model was trained on a particular movie, it should be able to recognize frames from that movie. If it wasn’t, it should have a much harder time identifying them.
            </p>
            <p>
              If you are still unsure about this idea, below, you'll find an interactive challenge where you can try to perform the same task the models did. Can you score better than GPT-4o? 👀
            </p>
          </div>
        </div>
      </div>
    </div>
  </section>


  <!-- Quiz Section with manual "carousel" (Prev/Next) -->
  <!-- <div class="has-background-light"> -->
    <section class="section" id="quiz" style="margin-top: -2rem; margin-bottom: -2.5rem;">
      <div class="container is-max-desktop">
        <h2 class="title is-3 has-text-centered">
          Movie Guessing Quiz
        </h2>
        <!-- Quiz image container -->
        <div id="quiz-frame" style="background: none; display: flex; justify-content: center;">
          <figure class="image chart-or-image" style="margin: auto 0; width: 60%; position: relative;">
            <!-- The quiz image -->
            <img id="quiz-image" src="./static/images/quiz_images/quiz1.png" alt="Movie Frame" style="width: 100%; height: auto; display: block;">
            <!-- The SVG chart (initially hidden) -->
            <svg id="bar-chart" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none;"></svg>
          </figure>
        </div>

        <!-- Navigation controls + Dot Indicators -->
        <div class="navigation-controls" style="text-align: center; margin-top: 1rem;">
          <button id="prev-btn" class="button is-info round-button" style="margin-right: 1rem;">
            <i class="fas fa-arrow-left"></i>
          </button>
          <div id="dot-indicators"></div>
          <button id="next-btn" class="button is-info round-button" style="margin-left: 1rem;">
            <i class="fas fa-arrow-right"></i>
          </button>
        </div>
        
        <!-- New wrapper containing both the quiz (TomSelect) and the submit button -->
        <div id="quiz-answer-wrapper">
          <!-- Quiz container: holds the TomSelect form -->
          <div id="quiz-container" class="answer-container">
            <label class="label">What movie is present in this frame?</label>
            <!-- Plain <select> for TomSelect to transform -->
            <select id="quiz-answer" name="quiz-answer" placeholder="Select a movie...">
              <option value="-" selected>-</option>
            </select>
          </div>
          <!-- Submit container: holds the final submission button -->
          <div id="submit-container" class="field" style="margin-top: 1.5rem; text-align: center;">
            <button id="submit-all">Submit All Guesses</button>
          </div>
        </div>
      </div>
    </section>
  <!-- </div> -->

  <script>
    document.addEventListener('DOMContentLoaded', function() {
  
      /*************************************************************
       * GLOBAL SETUP
       *************************************************************/
      const quizImages = [
        './static/images/quiz_images/quiz1.png',
        './static/images/quiz_images/quiz2.png',
        './static/images/quiz_images/quiz3.png',
        './static/images/quiz_images/quiz4.png',
        './static/images/quiz_images/quiz5.png',
        './static/images/quiz_images/quiz6.png',
        './static/images/quiz_images/quiz7.png',
        './static/images/quiz_images/quiz8.png'
      ];
      const correctAnswers = [
        'La La Land',
        'The Da Vinci Code',
        'Jurassic Park',
        'Baywatch',
        'Notting Hill',
        'Life of Pi',
        'The Greatest Showman',
        'Pride & Prejudice'
      ];
  
      const totalSlides = quizImages.length + 1;  
      let currentIndex = 0;  
      let userAnswers = new Array(quizImages.length).fill('-');
  
      // Just a flag to know if we've at least drawn the chart structure once
      let chartStructureDrawn = false;
  
      // DOM references
      const quizImageEl = document.getElementById('quiz-image');
      const quizContainer = document.getElementById('quiz-container');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const submitBtn = document.getElementById('submit-all');
      const barChartSvg = document.getElementById('bar-chart');
      const quizWrapper = document.getElementById('quiz-answer-wrapper');
      const dotContainer = document.getElementById('dot-indicators');
  
      // Create dot indicators
      for (let i = 0; i < totalSlides; i++) {
        const dot = document.createElement('span');
        dot.classList.add('dot');
        if (i === 0) dot.classList.add('active');
        dotContainer.appendChild(dot);
      }
  
      let quizSelect; // We'll define it after loading the movie titles
  
      /*************************************************************
       * DOTS: Jump to a specific slide
       *************************************************************/
      const dots = document.querySelectorAll('#dot-indicators .dot');
      dots.forEach((dot, index) => {
        dot.addEventListener('click', () => {
          // Save current slide’s answer before navigation
          if (currentIndex < quizImages.length && quizSelect) {
            userAnswers[currentIndex] = quizSelect.getValue();
          }
          currentIndex = index;
          updateSlide();
        });
      });
  
      function updateDots() {
        const allDots = dotContainer.querySelectorAll('.dot');
        allDots.forEach((dot, idx) => {
          dot.classList.toggle('active', idx === currentIndex);
        });
      }
  
      /*************************************************************
       * 1) Load TomSelect Options
       *************************************************************/
      fetch('./static/data/movie_titles_mini.txt')
        .then(res => res.text())
        .then(data => {
          const lines = data.split('\n')
                            .map(x => x.trim())
                            .filter(x => x.length > 0);
  
          const selectEl = document.getElementById('quiz-answer');
          for (const movie of lines) {
            const option = document.createElement('option');
            option.value = movie;
            option.textContent = movie;
            selectEl.appendChild(option);
          }
  
          quizSelect = new TomSelect('#quiz-answer', {
            create: false,
            maxItems: 1,
            allowEmptyOption: true,
            placeholder: 'Select a movie...',
            maxOptions: 7000,
            onItemAdd: function() { this.blur(); },
            onType: function() {
              if (this.getValue()) this.clear();
            }
          });
  
          quizSelect.setValue('-');
  
          // Set the wrapper height based on TomSelect container’s height
          quizWrapper.style.height = quizContainer.offsetHeight + 'px';
        })
        .catch(err => console.error('Error loading movie_titles_mini.txt:', err));
  
      /*************************************************************
       * 2) Chart + Legend Functions
       *************************************************************/
      const borderWidth = 2;
      const barWidthFraction = 0.8;
  
      function drawChartStructure() {
        const svg = d3.select(barChartSvg);
  
        // Clear old content
        svg.selectAll('*').remove();
  
        // Measure bounding box AFTER ensuring it's visible
        const bbox = barChartSvg.getBoundingClientRect();
        const width  = bbox.width + 20;
        const height = bbox.height;
  
        const margin = { top: 45, right: 50, bottom: 10, left: 60 };
        const innerWidth  = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
  
        // Main group
        const g = svg.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);
  
        // Y scale
        const yScale = d3.scaleLinear()
          .domain([0, 105]) // up to 105% for some padding
          .range([innerHeight, 0]);
  
        // Y axis
        const yAxis = d3.axisLeft(yScale)
          .ticks(5)
          .tickSizeInner(0)
          .tickSizeOuter(0)
          .tickPadding(7);
        g.append("g")
          .attr("class", "y-axis axis")
          .call(yAxis);
  
        // Horizontal grid lines (excluding y=0 line)
        const yTicks = yScale.ticks(5).filter(t => t !== 0);
        g.append("g")
          .attr("class", "grid horizontal-grid")
          .call(
            d3.axisLeft(yScale)
              .tickValues(yTicks)
              .tickSize(-innerWidth)
              .tickFormat("")
          )
          .selectAll("line")
            .attr("stroke", "lightgray")
            .attr("stroke-dasharray", "5")
            .attr("stroke-width", "2");
  
        // X scale
        const categories = ["You", "Qwen2-VL 72B", "GPT-4o", "Gemini-1.5 Pro"];
        const xScale = d3.scaleBand()
          .domain(categories)
          .range([0, innerWidth])
          .padding(0.2);
  
        // Vertical grid lines
        categories.forEach(cat => {
          const xPos = xScale(cat) + xScale.bandwidth() / 2;
          g.append("line")
            .attr("class", "grid vertical-grid")
            .attr("x1", xPos)
            .attr("y1", 0)
            .attr("x2", xPos)
            .attr("y2", innerHeight)
            .attr("stroke", "lightgray")
            .attr("stroke-dasharray", "5")
            .attr("stroke-width", "2");
        });
  
        // Borders (top, right, left, bottom)
        g.append("line")
          .attr("class", "border")
          .attr("x1", 0).attr("y1", 0)
          .attr("x2", innerWidth).attr("y2", 0)
          .attr("stroke", "lightgray")
          .attr("stroke-width", borderWidth);
  
        g.append("line")
          .attr("class", "border")
          .attr("x1", innerWidth).attr("y1", 0)
          .attr("x2", innerWidth).attr("y2", innerHeight)
          .attr("stroke", "lightgray")
          .attr("stroke-width", borderWidth);
  
        g.append("line")
          .attr("class", "border")
          .attr("x1", 0).attr("y1", -1)
          .attr("x2", 0).attr("y2", innerHeight + 1)
          .attr("stroke", "#36454F")
          .attr("stroke-width", borderWidth);
  
        g.append("line")
          .attr("class", "border")
          .attr("x1", -1).attr("y1", innerHeight)
          .attr("x2", innerWidth).attr("y2", innerHeight)
          .attr("stroke", "#36454F")
          .attr("stroke-width", borderWidth);
  
        // --- New Modification: Add Y-Axis Title ---
        // Wait for the y-axis ticks to render, get one tick's computed font size,
        // add 2px, and use that for the title.
        const tickLabelEl = g.select(".y-axis").select("text").node();
        let computedFontSize = 12; // default fallback
        if (tickLabelEl) {
          computedFontSize = parseFloat(window.getComputedStyle(tickLabelEl).fontSize);
        }
        const titleFontSize = computedFontSize + 3;
        g.append("text")
          .attr("class", "y-axis-title")
          .attr("transform", "rotate(-90)")
          .attr("x", -innerHeight / 2)
          .attr("y", -margin.left + (margin.left * 0.4))
          .attr("text-anchor", "middle")
          .style("font-size", titleFontSize + "px")
          .style("fill", "#464646")
          .text("Accuracy (%)");
  
        // Draw the static bars for other models
        drawInitialBars(g, innerWidth, innerHeight, yScale, xScale);
        drawLegend(g, innerWidth, innerHeight);
      }
  
      function drawInitialBars(g, innerWidth, innerHeight, yScale, xScale) {
        const staticData = [
          { name: "Qwen2-VL 72B",   value: 75,   color: "#695e93e6" },  
          { name: "GPT-4o",         value: 87.5, color: "#7bb296e6" },
          { name: "Gemini-1.5 Pro", value: 75,   color: "#f6d379e6" }
        ];
  
        staticData.forEach(d => {
          const fullBandWidth = xScale.bandwidth();
          const barWidth = fullBandWidth * barWidthFraction;
          const xPos = xScale(d.name) + (fullBandWidth - barWidth) / 2;
  
          // Place them at y=innerHeight initially (height=0), to animate up if desired
          g.append("rect")
            .attr("class", "static-bar")
            .attr("x", xPos)
            .attr("y", innerHeight)
            .attr("width", barWidth)
            .attr("height", 0)
            .attr("fill", d.color)
            .attr("stroke", "black")
            .attr("stroke-width", borderWidth)
            .attr("data-final", d.value);
        });
      }
  
      function drawLegend(g, innerWidth, innerHeight) {
        g.selectAll(".legend").remove();
  
        const legendData = [
          { name: "You",            color: "#1c2e4ae6" },
          { name: "Qwen2-VL 72B",   color: "#695e93e6" },
          { name: "GPT-4o",         color: "#7bb296e6" },
          { name: "Gemini-1.5 Pro", color: "#f6d379e6" },
        ];
  
        const legendGroup = g.append("g")
          .attr("class", "legend")
          .attr("transform", "translate(0, -25)");
  
        const items = legendGroup.selectAll(".legend-item")
          .data(legendData)
          .enter()
          .append("g")
          .attr("class", "legend-item");
  
        // We'll try single-line first; if it doesn't fit, do grid
        function attemptSingleLine(fontSize, squareSize) {
          items.selectAll("*").remove();
          items.append("rect")
            .attr("fill", d => d.color)
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("width", squareSize)
            .attr("height", squareSize);
  
          items.append("text")
            .text(d => d.name)
            .attr("font-family", "Roboto, sans-serif")
            .attr("font-size", fontSize)
            .attr("x", squareSize + 5)
            .attr("y", squareSize * 0.9);
  
          let xPos = 0;
          let totalWidth = 0;
          const itemGap = 25;
  
          items.each(function(d, i) {
            d3.select(this).attr("transform", `translate(${xPos}, 0)`);
            const bbox = this.getBBox();
            totalWidth += bbox.width;
            if (i < legendData.length - 1) {
              totalWidth += itemGap;
            }
            xPos += bbox.width + itemGap;
          });
          return totalWidth;
        }
  
        function attemptGrid(fontSize, squareSize) {
          items.selectAll("*").remove();
          items.append("rect")
            .attr("fill", d => d.color)
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("width", squareSize)
            .attr("height", squareSize);
  
          items.append("text")
            .text(d => d.name)
            .attr("font-family", "Roboto, sans-serif")
            .attr("font-size", fontSize)
            .attr("x", squareSize + 5)
            .attr("y", squareSize * 0.8);
  
          // measure bounding boxes
          const nodeBboxes = [];
          items.each(function() { nodeBboxes.push(this.getBBox()); });
  
          const colSpacing = 5, rowSpacing = -15;
          const widthCol0 = Math.max(nodeBboxes[0].width, nodeBboxes[2]?.width || 0);
          const widthCol1 = Math.max(nodeBboxes[1].width, nodeBboxes[3]?.width || 0);
  
          // place them in two columns
          const y0 = -15;
          d3.select(items.nodes()[0]).attr("transform", `translate(0, ${y0})`);
          d3.select(items.nodes()[1]).attr("transform", `translate(${widthCol0 + colSpacing}, ${y0})`);
  
          const y1 = nodeBboxes[0].height + rowSpacing;
          d3.select(items.nodes()[2]).attr("transform", `translate(0, ${y1})`);
          d3.select(items.nodes()[3]).attr("transform", `translate(${widthCol0 + colSpacing}, ${y1})`);
  
          const groupBbox = legendGroup.node().getBBox();
          return groupBbox.width;
        }
  
        const maxFontSize = 16, minFontSize = 8;
        const maxSquareSize = 14, minSquareSize = 6;
        const shrinkStep = 1;
  
        let fontSize = maxFontSize,
            squareSize = maxSquareSize;
        let fitsSingleLine = false;
  
        while (true) {
          const totalWidth = attemptSingleLine(fontSize, squareSize);
          if (totalWidth <= innerWidth) {
            fitsSingleLine = true;
            break;
          } else {
            fontSize   -= shrinkStep;
            squareSize -= shrinkStep;
            if (fontSize < minFontSize || squareSize < minSquareSize) {
              break;
            }
          }
        }
  
        if (fitsSingleLine) {
          const bbox = legendGroup.node().getBBox();
          const offsetX = Math.max(0, (innerWidth - bbox.width) / 2);
          legendGroup.attr("transform", `translate(${offsetX}, -25)`);
        } else {
          fontSize = maxFontSize;
          squareSize = maxSquareSize;
          while (true) {
            const finalWidth = attemptGrid(fontSize, squareSize);
            if (finalWidth <= innerWidth) {
              break;
            } else {
              fontSize   -= shrinkStep;
              squareSize -= shrinkStep;
              if (fontSize < minFontSize || squareSize < minSquareSize) {
                break;
              }
            }
          }
          const bbox = legendGroup.node().getBBox();
          const offsetX = Math.max(0, (innerWidth - bbox.width) / 2);
          legendGroup.attr("transform", `translate(${offsetX}, -25)`);
        }
      }
  
      // Animate user bar + static bars
      function animateAllBars(finalYouValue) {
        const svg = d3.select(barChartSvg);
        const bbox = barChartSvg.getBoundingClientRect();
        const width  = bbox.width + 20;
        const height = bbox.height;
  
        const margin = { top: 45, right: 50, bottom: 10, left: 60 };
        const innerWidth  = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
  
        const yScale = d3.scaleLinear()
          .domain([0, 105])
          .range([innerHeight, 0]);
  
        const categories = ["You", "Qwen2-VL 72B", "GPT-4o", "Gemini-1.5 Pro"];
        const xScale = d3.scaleBand()
          .domain(categories)
          .range([0, innerWidth])
          .padding(0.2);
  
        const g = svg.select("g");
  
        // Animate the static bars
        g.selectAll(".static-bar")
          .transition()
          .duration(1200)
          .attr("y", function() {
            const finalVal = +d3.select(this).attr("data-final");
            return yScale(finalVal);
          })
          .attr("height", function() {
            const finalVal = +d3.select(this).attr("data-final");
            return innerHeight - yScale(finalVal);
          });
  
        // Remove old “You” bar if any
        g.selectAll(".animated-bar").remove();
  
        // Draw new “You” bar
        const fullBandWidth = xScale.bandwidth();
        const barWidth = fullBandWidth * barWidthFraction;
        const xPos = xScale("You") + (fullBandWidth - barWidth) / 2;
  
        const youBar = g.append("rect")
          .attr("class", "animated-bar")
          .attr("x", xPos)
          .attr("y", innerHeight)
          .attr("width", barWidth)
          .attr("height", 0)
          .attr("fill", "#1c2e4ae6")
          .attr("stroke", "black")
          .attr("stroke-width", borderWidth);
  
        // Transition “You” bar upward
        youBar.transition()
          .duration(1200)
          .attr("y", yScale(finalYouValue))
          .attr("height", innerHeight - yScale(finalYouValue));
      }
  
      /*************************************************************
       * SHOW CHART (structure only, no “You” bar)
       * Called whenever the final slide is shown, or upon window resize
       *************************************************************/
      function showChart() {
        // Make sure the chart is visible
        barChartSvg.style.display = 'block';
  
        // Wait one animation frame to ensure layout is final
        window.requestAnimationFrame(() => {
          // Clear any old chart
          d3.select('#bar-chart').selectAll('*').remove();
  
          // Draw the base chart structure (only static bars)
          drawChartStructure();
  
          // Mark that we've drawn it at least once
          chartStructureDrawn = true;
        });
      }
  
      /*************************************************************
       * UPDATE SLIDE
       *************************************************************/
      function updateSlide() {
        if (currentIndex < quizImages.length) {
          // Not the final slide
          quizImageEl.style.opacity = '1';
          quizImageEl.style.display = 'block';
          barChartSvg.style.display = 'none';  // hide chart
  
          // Show TomSelect, hide submit button
          quizWrapper.classList.remove('show-submit');
  
          quizImageEl.src = quizImages[currentIndex];
  
          // Restore user’s old choice if any
          if (quizSelect) {
            if (userAnswers[currentIndex] && userAnswers[currentIndex] !== '-') {
              quizSelect.setValue(userAnswers[currentIndex]);
            } else {
              quizSelect.clear();
              quizSelect.setValue('-');
            }
          }
  
        } else {
          // Final slide
          quizImageEl.style.opacity = '0';
          quizImageEl.style.display = 'block'; 
          quizWrapper.classList.add('show-submit');
  
          // Redraw the chart for the new layout
          showChart();
        }
  
        updateDots();
  
        // Update nav button styles
        if (currentIndex === 0) {
          prevBtn.style.setProperty('background-color', '#d3d3d3', 'important');
          prevBtn.style.setProperty('cursor', 'not-allowed', 'important');
          prevBtn.style.setProperty('opacity', '0.6', 'important');
        } else {
          prevBtn.style.setProperty('background-color', '#626161', 'important');
          prevBtn.style.setProperty('cursor', 'pointer', 'important');
          prevBtn.style.setProperty('opacity', '1', 'important');
        }
  
        if (currentIndex === totalSlides - 1) {
          nextBtn.style.setProperty('background-color', '#d3d3d3', 'important');
          nextBtn.style.setProperty('cursor', 'not-allowed', 'important');
          nextBtn.style.setProperty('opacity', '0.6', 'important');
        } else {
          nextBtn.style.setProperty('background-color', '#626161', 'important');
          nextBtn.style.setProperty('cursor', 'pointer', 'important');
          nextBtn.style.setProperty('opacity', '1', 'important');
        }
      }
  
      /*************************************************************
       * PREV / NEXT Buttons
       *************************************************************/
      prevBtn.addEventListener('click', () => {
        // Save current answer
        if (currentIndex < quizImages.length && quizSelect) {
          userAnswers[currentIndex] = quizSelect.getValue();
        }
        if (currentIndex > 0) {
          currentIndex--;
          updateSlide();
        }
        prevBtn.blur();
      });
  
      nextBtn.addEventListener('click', () => {
        // Save current answer
        if (currentIndex < quizImages.length && quizSelect) {
          userAnswers[currentIndex] = quizSelect.getValue();
        }
        if (currentIndex < totalSlides - 1) {
          currentIndex++;
          updateSlide();
        }
        nextBtn.blur();
      });
  
      /*************************************************************
       * SUBMIT ALL: ONLY THEN DO WE DRAW THE “YOU” BAR
       *************************************************************/
      submitBtn.addEventListener('click', () => {
        // If we're still on an image slide, save the user answer
        if (currentIndex < quizImages.length && quizSelect) {
          userAnswers[currentIndex] = quizSelect.getValue();
        }
  
        // Calculate accuracy
        let correctCount = 0;
        for (let i = 0; i < correctAnswers.length; i++) {
          if (userAnswers[i].trim().toLowerCase() === correctAnswers[i].trim().toLowerCase()) {
            correctCount++;
          }
        }
        const accuracy = (correctCount / correctAnswers.length) * 100;
  
        // Animate the user bar in the next animation frame
        window.requestAnimationFrame(() => {
          animateAllBars(accuracy);
        });
      });
  
      /*************************************************************
       * INIT: Start at Slide 0
       *************************************************************/
      updateSlide();
  
      // Remove focus on mobile after pointer/touch
      document.querySelectorAll('.round-button').forEach(btn => {
        btn.addEventListener('pointerup', function() { this.blur(); });
        btn.addEventListener('touchend', function() { this.blur(); });
      });
  
      /*************************************************************
       * ON RESIZE: If final slide is showing, re-draw the chart
       *************************************************************/
      window.addEventListener('resize', () => {
        // If user is currently on the final slide (chart is visible)
        if (currentIndex >= quizImages.length) {
          showChart(); // re-measure & re-draw from scratch
        }
      });
  
    });
  </script>
  
  
  
  
    

<!-- DIS-CO Section -->
<section class="section">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <div class="content has-text-justified">
          <p>
            Whether you completed the full quiz or just explored a few examples, we hope the key idea came accross: this task isn't easy! And for the cases you got right, think about it: had you seen those movies before? 🤔
          </p>
          <p>
            What we found particularly intriguing is that even with these highly neutral images, the models still manage to recognize most of them.
          </p>
          <p>
            This surprising ability led us to investigate the phenomenon more systematically, ultimately shaping our approach and leading to the development of <b>DIS-CO</b>.
          </p>


          <h2 class="title is-3">DIS-CO</h2>
          <div class="image-wrapper">
            <img src="./static/images/disco_pipeline.png" style="width: 100%; height: auto; display: block; margin: 0 auto;">
          </div>


          <p>
            We begin by assembling our <b>MovieTection</b> benchmark, where we collect 14,000 movie frames, categorized into main and neutral types to introduce varying levels of difficulty. For each frame, we also generate a corresponding caption using the Qwen2-VL 7B model.
          </p>
          <p>
            Models are then queried with both the image frames and their corresponding captions, generating free-form predictions for each. We can then refine our detection of suspect content by excluding cases where the image-based predictions overlap with caption-based ones.
          </p>
          <p>
              Our rationale is that when a model correctly identifies a movie based solely on its caption, it suggests that the frame could be highly representative of the movie. So much so that even a textual description provides enough clues for the model to make an accurate guess using its general knowledge acquired from public data (i.e. 
              <a href="https://aclanthology.org/L16-1147.pdf" target="_blank" rel="noopener noreferrer" style="color: #2C497F;">OpenSubtitles</a>), rather than relying on memorization.
          </p>
          <p>
            Finally, when deciding whether a suspect movie was part of a model’s training data, we compare its task performance against a baseline value reflecting general movie knowledge. If a movie’s recognition rate is significantly higher than expected - especially after removing cases where captions alone were sufficient for identification - it strongly suggests the model may have been exposed to that content during training.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>


<!-- Findings Section -->
<section class="section" style="margin-top: -2rem;">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <div class="content has-text-justified">
          <h2 class="title is-3">Key Findings</h2>
          <h3 class="title is-4">DIS-CO outperforms existing approaches</h3>
        <!-- Custom Tab Interface -->
        <div class="custom-tabs">
          <ul>
            <li class="is-active" data-view="suspect">Suspect</li>
            <li data-view="clean">Clean</li>
          </ul>
        </div>

        <!-- Table Card for Suspect Data -->
        <div id="table-container-suspect" class="table-card">
          <table class="table is-bordered is-hoverable">
            <caption>Accuracy scores on MovieTection<br>Suspect Split - Neutral Frames</caption>
            <thead>
              <tr>
                <th></th>
                <th>GPT-4o</th>
                <th>Gemini-1.5 Pro</th>
                <th>LLaMA-3.2 90B</th>
                <th>Qwen2-VL 72B</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th>Captions</th>
                <td>0.128</td>
                <td>0.079</td>
                <td>0.078</td>
                <td>0.075</td>
              </tr>
              <tr>
                <th>MCQA</th>
                <td>0.721</td>
                <td>0.550</td>
                <td>0.540</td>
                <td>0.617</td>
              </tr>
              <tr>
                <th>⌊DIS-CO⌋</th>
                <td>0.226</td>
                <td>0.152</td>
                <td>0.134</td>
                <td>0.122</td>
              </tr>
              <tr>
                <th>DIS-CO</th>
                <td>0.338</td>
                <td>0.209</td>
                <td>0.176</td>
                <td>0.176</td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Table Card for Clean Data (initially hidden) -->
        <div id="table-container-clean" class="table-card" style="display: none;">
          <table class="table is-bordered is-hoverable">
            <caption>Accuracy scores on MovieTection<br>Clean Split - Neutral Frames</caption>
            <thead>
              <tr>
                <th></th>
                <th>GPT-4o</th>
                <th>Gemini-1.5 Pro</th>
                <th>LLaMA-3.2 90B</th>
                <th>Qwen2-VL 72B</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th>Captions</th>
                <td>0.001</td>
                <td>0.000</td>
                <td>0.000</td>
                <td>0.001</td>
              </tr>
              <tr>
                <th>MCQA</th>
                <td>0.410</td>
                <td>0.295</td>
                <td>0.295</td>
                <td>0.149</td>
              </tr>
              <tr>
                <th>⌊DIS-CO⌋</th>
                <td>0.002</td>
                <td>0.004</td>
                <td>0.005</td>
                <td>0.000</td>
              </tr>
              <tr>
                <th>DIS-CO</th>
                <td>0.010</td>
                <td>0.010</td>
                <td>0.013</td>
                <td>0.000</td>
              </tr>
            </tbody>
          </table>
        </div>
        <article class="message is-info">
          <div class="message-body">
            <strong>Note.</strong> The two DIS-CO variants differ in whether the overlap between caption-based and image-based predictions was removed. ⌊DIS-CO⌋ applies this removal, while DIS-CO considers all frames.
          </div>
        </article>

        <script>
          document.addEventListener('DOMContentLoaded', function() {
            const tabs = document.querySelectorAll('.custom-tabs ul li');
            const suspectContainer = document.getElementById('table-container-suspect');
            const cleanContainer = document.getElementById('table-container-clean');
          
            tabs.forEach(tab => {
              tab.addEventListener('click', () => {
                // Remove active state from all tabs
                tabs.forEach(t => t.classList.remove('is-active'));
                // Activate the clicked tab
                tab.classList.add('is-active');
          
                // Toggle the table containers with a smooth transition
                if (tab.getAttribute('data-view') === 'suspect') {
                  suspectContainer.style.display = 'block';
                  cleanContainer.style.display = 'none';
                } else {
                  suspectContainer.style.display = 'none';
                  cleanContainer.style.display = 'block';
                }
              });
            });
          });
          </script>

        <ul>
          <li>
            MCQA achieves high accuracy on suspect movies but also presents false positives on clean movies. This tradeoff reduces its reliability, as it misclassifies clean content as suspect.
          </li>
          <li>
            Captions are weak indicators of memorization. Their suspect-level accuracy remains low across models, with Qwen2-VL 72B performing below 10%, highlighting their limitations.
          </li>
          <li>
            Both DIS-CO variants improve detection for suspect movies, while clean movies are hardly guessed, indicating that DIS-CO is false-positive free.
          </li>
        </ul>

        <h3 class="title is-4">Popular and Higher-Quality movies are more easily recognized</h3>

<!-- HTML: Two charts side by side, each 45% wide with a small gap -->
<div style="display: flex; justify-content: space-between; gap: 10px;">
  <svg id="line-chart-1" width="50%"></svg>
  <svg id="line-chart-2" width="50%"></svg>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Draw both charts initially
    drawLineChart("#line-chart-1");
    drawLineChart("#line-chart-2");

    // Redraw on window resize
    window.addEventListener('resize', () => {
      drawLineChart("#line-chart-1");
      drawLineChart("#line-chart-2");
    });
  });

  /**
   * Main function to draw a line chart within the provided SVG selector.
   */
  function drawLineChart(svgSelector) {
    const svg = d3.select(svgSelector);
    svg.selectAll('*').remove(); // Clear previous content

    // Get container dimensions and compute chart height using an aspect ratio.
    const container = document.querySelector(svgSelector);
    const { width } = container.getBoundingClientRect();
    const height = width * 0.9; // Adjust aspect ratio as needed

    // Configure responsive SVG attributes.
    svg.attr("viewBox", `0 0 ${width} ${height}`)
       .attr("preserveAspectRatio", "xMidYMid meet");

    /**
     * Define margins (clamped to prevent excessive or tiny margins).
     */
    const margin = {
      top: Math.min(height * 0.20, 100),
      right: Math.min(width * 0.05, 40),
      bottom: Math.min(height * 0.15, 100),
      left: Math.min(width * 0.15, 60)
    };

    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    // Create a group for the chart content.
    const g = svg.append("g")
                 .attr("transform", `translate(${margin.left}, ${margin.top})`);

    // Define scales, tick values, and data conditionally.
    let xScale, xTickValues, linesData;
    if (svgSelector === "#line-chart-2") {
      // Right chart: x-axis domain starts at 3.5 for extra left padding, with ticks from 4 to 9.
      xScale = d3.scaleLinear()
                 .domain([3.5, 9.5])
                 .range([0, innerWidth]);
      xTickValues = [4, 5, 6, 7, 8, 9];

      linesData = [
        {
          name: "GPT-4o",
          color: "#7bb296e6",
          values: [
            { x: 3.8, y: 56 },
            { x: 4.3, y: 41 },
            { x: 5.5, y: 37 },
            { x: 6, y: 39 },
            { x: 7.3, y: 63 },
            { x: 8.3, y: 80 },
            { x: 9, y: 96 }
          ]
        },
        {
          name: "Gemini-1.5-Pro",
          color: "#f6d379e6",
          values: [
            { x: 3.8, y: 41 },
            { x: 4.3, y: 23 },
            { x: 5.5, y: 28 },
            { x: 6, y: 22 },
            { x: 7.3, y: 41 },
            { x: 8.3, y: 78 },
            { x: 9, y: 20 }
          ]
        },
        {
          name: "Qwen2-VL 72B",
          color: "#695e93e6",
          values: [
            { x: 3.8, y: 18 },
            { x: 4.3, y: 22 },
            { x: 5.5, y: 19 },
            { x: 6, y: 24 },
            { x: 7.3, y: 29 },
            { x: 8.3, y: 62 },
            { x: 9, y: 57 }
          ]
        },
        {
          name: "Llama-3.2 90B",
          color: "#ff9671",
          values: [
            { x: 3.8, y: 16 },
            { x: 4.3, y: 18 },
            { x: 5.5, y: 17 },
            { x: 6, y: 18 },
            { x: 7.3, y: 31 },
            { x: 8.3, y: 64 },
            { x: 9, y: 63 }
          ]
        }
      ];
    } else {
      // Left chart: original x-axis and data.
      xScale = d3.scaleLinear()
                 .domain([1e8, 2.4e9])
                 .range([0, innerWidth]);
      xTickValues = [];
      for (let val = 2e8; val <= 2.2e9; val += 4e8) {
        xTickValues.push(val);
      }

      linesData = [
        {
          name: "GPT-4o",
          color: "#7bb296e6",
          values: [
            { x: 2.0e8,  y: 58 },
            { x: 3.0e8,  y: 58 },
            { x: 5.0e8,  y: 77 },
            { x: 7.9e8,  y: 80 },
            { x: 9.0e8,  y: 59 },
            { x: 1.3e9,  y: 85 },
            { x: 2.26e9, y: 82 }
          ]
        },
        {
          name: "Gemini-1.5-Pro",
          color: "#f6d379e6",
          values: [
            { x: 2.0e8,  y: 39 },
            { x: 3.0e8,  y: 40 },
            { x: 5.0e8,  y: 58 },
            { x: 7.9e8,  y: 66 },
            { x: 9.0e8,  y: 50 },
            { x: 1.3e9,  y: 68 },
            { x: 2.26e9, y: 78 }
          ]
        },
        {
          name: "Qwen2-VL 72B",
          color: "#695e93e6",
          values: [
            { x: 2.0e8,  y: 33 },
            { x: 3.0e8,  y: 36 },
            { x: 5.0e8,  y: 21 },
            { x: 7.9e8,  y: 39 },
            { x: 9.0e8,  y: 35 },
            { x: 1.3e9,  y: 61 },
            { x: 2.26e9, y: 64 }
          ]
        },
        {
          name: "Llama-3.2 90B",
          color: "#ff9671",
          values: [
            { x: 2.0e8,  y: 43 },
            { x: 3.0e8,  y: 43 },
            { x: 5.0e8,  y: 42 },
            { x: 7.9e8,  y: 28 },
            { x: 9.0e8,  y: 42 },
            { x: 1.3e9,  y: 71 },
            { x: 2.26e9, y: 65 }
          ]
        }
      ];
    }

    // Define y-scale (same for both charts).
    const yScale = d3.scaleLinear()
                     .domain([0, 105])
                     .range([innerHeight, 0]);

    // Draw axes (with dynamic tick font sizes), gridlines, and borders.
    drawAxis(g, xScale, yScale, innerWidth, innerHeight, xTickValues, width);
    drawGridlines(g, xScale, yScale, innerWidth, innerHeight, xTickValues);
    drawBorders(g, innerWidth, innerHeight);

    // Draw axis titles (x-axis title depends on chart; y-axis title is shared)
    const xTitle = svgSelector === "#line-chart-2" ? "IMDb Rating" : "Box-Office ($)";
    const yTitle = "Accuracy (%)";
    drawAxisTitles(g, innerWidth, innerHeight, margin, width, xTitle, yTitle);

    // Create a line generator for smooth curves.
    const lineGenerator = d3.line()
                            .x(d => xScale(d.x))
                            .y(d => yScale(d.y))
                            .curve(d3.curveLinear);

    // Draw each line and its data points.
    linesData.forEach(({ name, color, values }) => {
      // Draw the line.
      g.append("path")
       .datum(values)
       .attr("fill", "none")
       .attr("stroke", color)
       .attr("stroke-width", 3)
       .attr("d", lineGenerator);

      // Draw circles at each data point.
      g.selectAll(`.circle-${sanitizeClassName(name)}`)
       .data(values)
       .enter()
       .append("circle")
         .attr("class", `circle-${sanitizeClassName(name)}`)
         .attr("fill", color)
         .attr("stroke", "black")
         .attr("stroke-width", 1)
         .attr("r", 4)
         .attr("cx", d => xScale(d.x))
         .attr("cy", d => yScale(d.y));
    });

    // Draw the legend with dynamic sizing.
    drawLegend(g, innerWidth, linesData, width);
  }

  /**
   * Draw x-axis and y-axis. The tick labels' font sizes scale with the overall chart width.
   */
  function drawAxis(g, xScale, yScale, innerWidth, innerHeight, xTickValues, svgWidth) {
    // Calculate dynamic font size for tick labels (e.g., 3% of the overall chart width).
    const tickFontSize = svgWidth * 0.035;

    // Conditionally set the tick format for the x-axis.
    let xAxis;
    if (xScale.domain()[1] < 10) {
      // For the right chart, format ticks as plain integers.
      xAxis = d3.axisBottom(xScale)
                .tickValues(xTickValues)
                .tickFormat(d3.format("d"));
    } else {
      // For the left chart, use the original formatting.
      xAxis = d3.axisBottom(xScale)
                .tickValues(xTickValues)
                .tickFormat(d =>
                  d >= 1e9 ? (d / 1e9).toFixed(1) + "B" :
                  (d / 1e6).toFixed(0) + "M"
                );
    }
    g.append("g")
     .attr("class", "x-axis")
     .attr("transform", `translate(0, ${innerHeight})`)
     .call(xAxis)
     .selectAll("text")
       .attr("font-family", "Roboto, sans-serif")
       .attr("font-size", tickFontSize)
       .attr("fill", "#464646")
       .attr("font-weight", "500");

    // Y-axis.
    const yAxis = d3.axisLeft(yScale)
                    .ticks(5)
                    .tickSizeInner(0)
                    .tickSizeOuter(0)
                    .tickPadding(7);
    g.append("g")
     .attr("class", "y-axis")
     .call(yAxis)
     .selectAll("text")
       .attr("font-family", "Roboto, sans-serif")
       .attr("font-size", tickFontSize)
       .attr("fill", "#464646")
       .attr("font-weight", "500");
  }

  /**
   * Draw horizontal and vertical gridlines.
   */
  function drawGridlines(g, xScale, yScale, innerWidth, innerHeight, xTickValues) {
    const yTicks = yScale.ticks(5).filter(t => t !== 0);

    // Horizontal gridlines.
    g.append("g")
     .attr("class", "grid horizontal-grid")
     .call(
       d3.axisLeft(yScale)
         .tickValues(yTicks)
         .tickSize(-innerWidth)
         .tickFormat('')
     )
     .selectAll("line")
       .attr("stroke", "lightgray")
       .attr("stroke-dasharray", "5")
       .attr("stroke-width", 2);

    // Vertical gridlines.
    g.append("g")
     .attr("class", "grid vertical-grid")
     .selectAll("line")
     .data(xTickValues)
     .enter()
     .append("line")
       .attr("x1", d => xScale(d))
       .attr("y1", 0)
       .attr("x2", d => xScale(d))
       .attr("y2", innerHeight)
       .attr("stroke", "lightgray")
       .attr("stroke-dasharray", "5")
       .attr("stroke-width", 2);
  }

  /**
   * Draw borders around the plot area.
   */
  function drawBorders(g, innerWidth, innerHeight) {
    // Top border.
    g.append("line")
     .attr("x1", 0).attr("y1", 0)
     .attr("x2", innerWidth).attr("y2", 0)
     .attr("stroke", "lightgray")
     .attr("stroke-width", 2);

    // Right border.
    g.append("line")
     .attr("x1", innerWidth).attr("y1", 0)
     .attr("x2", innerWidth).attr("y2", innerHeight)
     .attr("stroke", "lightgray")
     .attr("stroke-width", 2);

    // Left border.
    g.append("line")
     .attr("x1", 0).attr("y1", 0)
     .attr("x2", 0).attr("y2", innerHeight)
     .attr("stroke", "#36454F")
     .attr("stroke-width", 2);

    // Bottom border.
    g.append("line")
     .attr("x1", 0).attr("y1", innerHeight)
     .attr("x2", innerWidth).attr("y2", innerHeight)
     .attr("stroke", "#36454F")
     .attr("stroke-width", 2);
  }

  /**
   * Sanitize strings for use as CSS class names.
   */
  function sanitizeClassName(name) {
    return name.replace(/\s/g, '').replace(/\./g, '-');
  }

  /**
   * Draw a responsive 2x2 legend.
   */
  function drawLegend(g, innerWidth, linesData, svgWidth) {
    // Remove any existing legend.
    g.selectAll(".legend").remove();

    const legendData = linesData.map(({ name, color }) => ({ name, color }));
    const legendGroup = g.append("g").attr("class", "legend");
    const legendItems = legendGroup.selectAll(".legend-item")
                                   .data(legendData)
                                   .enter()
                                   .append("g")
                                   .attr("class", "legend-item");

    // Let the font and squares scale with the overall SVG width.
    const fontSize = svgWidth * 0.035;    // 3% of the chart width.
    const squareSize = svgWidth * 0.025;    // 2% of the chart width.
    const colSpacing = 20;
    const rowSpacing = 0;

    // Draw colored squares.
    legendItems.append("rect")
               .attr("fill", d => d.color)
               .attr("stroke", "black")
               .attr("stroke-width", 1)
               .attr("width", squareSize)
               .attr("height", squareSize);

    // Draw legend text.
    legendItems.append("text")
               .text(d => d.name)
               .attr("font-family", "Roboto, sans-serif")
               .attr("font-size", fontSize)
               .attr("fill", "black")
               .attr("x", squareSize + 5)
               .attr("y", squareSize * 0.95);

    // Position legend items in a 2x2 grid after rendering.
    requestAnimationFrame(() => {
      const items = legendGroup.selectAll(".legend-item").nodes();
      let col0MaxWidth = 0;
      items.forEach((item, i) => {
        if (i % 2 === 0) {
          const bbox = item.getBBox();
          col0MaxWidth = Math.max(col0MaxWidth, bbox.width);
        }
      });
      items.forEach((item, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = (col === 0) ? 0 : col0MaxWidth + colSpacing;
        const y = row * (item.getBBox().height + rowSpacing);
        d3.select(item).attr("transform", `translate(${x}, ${y})`);
      });
      const legendBBox = legendGroup.node().getBBox();
      const offsetX = Math.max(0, (innerWidth - legendBBox.width) / 2);
      const offsetY = -Math.min(38, 0.1 * svgWidth);
      legendGroup.attr("transform", `translate(${offsetX}, ${offsetY})`);
    });
  }

  /**
   * Draw axis titles for the x-axis and y-axis.
   * @param {Object} g - The main group element for the chart.
   * @param {Number} innerWidth - The inner width of the chart.
   * @param {Number} innerHeight - The inner height of the chart.
   * @param {Object} margin - The margins used for the chart.
   * @param {Number} svgWidth - The overall width of the SVG element.
   * @param {String} xTitle - The title for the x-axis.
   * @param {String} yTitle - The title for the y-axis.
   */
  function drawAxisTitles(g, innerWidth, innerHeight, margin, svgWidth, xTitle, yTitle) {
    // Define a dynamic font size for the titles (adjust the multiplier as needed)
    const titleFontSize = svgWidth * 0.04;  // 4% of the SVG width

    // Append the x-axis title
    g.append("text")
      .attr("class", "x-axis-title")
      .attr("text-anchor", "middle")
      .attr("x", innerWidth / 2)
      .attr("y", innerHeight + margin.bottom - (margin.bottom * 0.25))
      .text(xTitle)
      .attr("font-size", titleFontSize)
      .attr("fill", "#464646")
      .attr("font-family", "Roboto, sans-serif");

    // Append the y-axis title (rotated)
    g.append("text")
      .attr("class", "y-axis-title")
      .attr("text-anchor", "middle")
      .attr("transform", "rotate(-90)")
      .attr("x", -innerHeight / 2)
      .attr("y", -margin.left + (margin.left * 0.35))
      .text(yTitle)
      .attr("font-size", titleFontSize)
      .attr("fill", "#464646")
      .attr("font-family", "Roboto, sans-serif");
  }
</script>





        <ul>
          <li>
            Our analysis shows that box-office success correlates with model recognition, suggesting that popular movies are more frequently included in training data.
          </li>
          <li>
            Higher IMDb-rated movies also tend to be more recognizable, indicating that high-quality can also be seen as a proxy for the likelihood of memorization.
          </li>
        </ul>


        
        

        </div>
      </div>
    </div>
  </div>
</section>












  
  
  

  
  






  <!-- BibTeX Section -->
  <section class="section" id="BibTeX">
    <div class="container is-max-desktop content">
      <h2 class="title">BibTeX</h2>
      <pre><code>@article{duarte_disco_2025,
  title={DIS-CO: Discovering Copyrighted Content in VLMs Training Data},
  author={André V. Duarte and Xuandong Zhao and Arlindo L. Oliveira and Lei Li},
  journal   = {Under-Review},
  year      = {2025},
}</code></pre>
    </div>
  </section>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="content has-text-centered">
        <a class="icon-link" href="./static/videos/nerfies_paper.pdf">
          <i class="fas fa-file-pdf"></i>
        </a>
        <a class="icon-link" href="https://github.com/keunhong" class="external-link" disabled>
          <i class="fab fa-github"></i>
        </a>
      </div>
      <div class="columns is-centered">
        <div class="column is-8">
          <div class="content">
            <p>
              This website is licensed under a 
              <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
                Creative Commons Attribution-ShareAlike 4.0 International License
              </a>.
            </p>
            <p>
              This means you are free to borrow the 
              <a href="https://github.com/nerfies/nerfies.github.io">source code</a> of this website;
              we just ask that you link back to this page in the footer.
              Please remember to remove the analytics code included in the header of the website which
              you do not want on your website.
            </p>
          </div>
        </div>
      </div>
    </div>
  </footer>
  
</body>
</html>
